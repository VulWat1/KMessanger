<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simple P2P Messenger (GitHub Pages)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:0;background:#0f172a;color:#e6eef8}
    .wrap{max-width:980px;margin:28px auto;padding:18px;background:linear-gradient(180deg,#0b1220, #071026);border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
    h1{font-size:20px;margin:0 0 12px}
    .cols{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    textarea, input, button{font:14px/1.2 monospace}
    textarea{width:100%;height:80px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:rgba(255,255,255,.02);color:inherit}
    .card{padding:12px;background:rgba(255,255,255,.02);border-radius:8px}
    label{display:block;margin-bottom:6px;font-size:13px;color:#9fb2d8}
    .small{font-size:13px;color:#9fb2d8}
    .chat{height:360px;overflow:auto;padding:8px;border-radius:8px;background:#021026;border:1px solid rgba(255,255,255,.03)}
    .msg{margin:6px 0;padding:8px;border-radius:8px;max-width:78%}
    .msg.me{background:#083a4a;margin-left:auto}
    .msg.them{background:#07324a}
    .controls{display:flex;gap:8px;align-items:center}
    .chats-list{max-height:360px;overflow:auto}
    .btn{padding:8px 10px;border-radius:8px;border:0;background:#0ea5a3;color:#021018;cursor:pointer}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.06);color:#9fb2d8}
    footer{margin-top:12px;font-size:13px;color:#9fb2d8}
    .hint{font-size:13px;color:#7da6cf}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Простой P2P мессенджер (для GitHub Pages)</h1>
    <p class="small">Этот файл можно положить в репозиторий и включить Pages. Работает без сервера: ручной сигналинг (копировать/вставить SDP). По умолчанию сообщения идут по WebRTC (шифруются DTLS). Если вы зададите пароль, перед отправкой сообщения они дополнительно будут зашифрованы AES‑GCM на стороне клиента.</p>

    <div class="cols">
      <div class="card">
        <label>Ваш ник (локально)</label>
        <input id="nick" placeholder="например: Kudaibergen" style="width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,.04);background:transparent;color:inherit">

        <label style="margin-top:8px">Пароль (необязательно) — для дополнительного шифрования сообщений</label>
        <input id="pass" placeholder="совет: договоритесь с собеседником" style="width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,.04);background:transparent;color:inherit">
        <div class="hint">Если пароль пустой — используется только встроенное шифрование WebRTC (DTLS). Установите одинаковый пароль у обоих собеседников для дополнительного E2EE.</div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,.03);margin:12px 0">

        <label>Создать офер (сгенерировать локальную SDP)</label>
        <div class="controls">
          <button id="makeOffer" class="btn">Создать офер</button>
          <button id="makeAnswer" class="btn ghost">Создать ответ (если вставлено чужое офер)</button>
        </div>

        <label style="margin-top:8px">Локальная SDP (скопируйте и отправьте собеседнику)</label>
        <textarea id="localSDP" readonly></textarea>

        <label>Вставьте удалённую SDP (от собеседника) и нажмите "Принять"</label>
        <textarea id="remoteSDP" placeholder="вставьте сюда офер/ответ собеседника"></textarea>
        <div style="display:flex;gap:8px;margin-top:6px"><button id="acceptRemote" class="btn">Принять</button><button id="reset" class="btn ghost">Сброс</button></div>
      </div>

      <div class="card">
        <label>Список чатов (локально)</label>
        <div class="chats-list card" id="chatsList">(нет подключений)</div>
        <hr style="border:none;border-top:1px solid rgba(255,255,255,.03);margin:12px 0">
        <label>Сообщения</label>
        <div class="chat" id="chat"></div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <input id="messageInput" placeholder="Введите сообщение" style="flex:1;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,.04);background:transparent;color:inherit">
          <button id="sendBtn" class="btn">Отправить</button>
        </div>
      </div>
    </div>

    <footer>
      <strong>Важно:</strong> WebRTC обеспечивает шифрование (DTLS) по умолчанию. Сигналинг (обмен SDP) — открытый канал: если вы не хотите, чтобы кто-то видел SDP при передаче, обмен делайте через безопасный канал. Источники: MDN WebRTC, Web Crypto API.
    </footer>
  </div>

  <script>
  // Простой P2P messenger с ручным сигналингом + опциональным AES-GCM на Web Crypto.

  // --- helpers для base64 <-> ArrayBuffer
  function bufToBase64(buf){return btoa(String.fromCharCode.apply(null,new Uint8Array(buf)))}
  function base64ToBuf(b64){var bin=atob(b64);var len=bin.length;var arr=new Uint8Array(len);for(var i=0;i<len;i++)arr[i]=bin.charCodeAt(i);return arr.buffer}

  // --- crypto helpers (derive key from passphrase)
  async function deriveKeyFromPassword(password, salt){
    const enc = new TextEncoder();
    const baseKey = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey({name:'PBKDF2',salt:salt,iterations:150000,hash:'SHA-256'}, baseKey,{name:'AES-GCM',length:256}, false, ['encrypt','decrypt']);
    return key;
  }
  async function encryptMessage(key, plaintext){
    const iv=crypto.getRandomValues(new Uint8Array(12));
    const enc=new TextEncoder();
    const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv:iv}, key, enc.encode(plaintext));
    return {iv:bufToBase64(iv), ct:bufToBase64(ct)};
  }
  async function decryptMessage(key, ivB64, ctB64){
    const iv=base64ToBuf(ivB64);
    const ct=base64ToBuf(ctB64);
    const dec=await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)}, key, ct);
    return new TextDecoder().decode(dec);
  }

  // --- UI refs
  const makeOfferBtn=document.getElementById('makeOffer');
  const makeAnswerBtn=document.getElementById('makeAnswer');
  const localSDP=document.getElementById('localSDP');
  const remoteSDP=document.getElementById('remoteSDP');
  const acceptRemote=document.getElementById('acceptRemote');
  const resetBtn=document.getElementById('reset');
  const chatEl=document.getElementById('chat');
  const sendBtn=document.getElementById('sendBtn');
  const msgInput=document.getElementById('messageInput');
  const chatsList=document.getElementById('chatsList');
  const nickEl=document.getElementById('nick');
  const passEl=document.getElementById('pass');

  // --- state
  let pc=null; // RTCPeerConnection
  let dc=null; // DataChannel
  let connId=null; // remote label
  let cryptoKey=null; // AES key (if pass provided)
  let salt=null; // used for PBKDF2

  function appendMsg(text, who='them'){
    const div=document.createElement('div');div.className='msg '+(who==='me'?'me':'them');div.textContent=text;chatEl.appendChild(div);chatEl.scrollTop=chatEl.scrollHeight;
  }

  function saveChat(label, message, who){
    const k='pm.chat.'+label;const arr=JSON.parse(localStorage.getItem(k)||'[]');arr.push({t:Date.now(),m:message,w:who});localStorage.setItem(k,JSON.stringify(arr));renderChats();
  }
  function renderChats(){
    chatsList.innerHTML='';for(const key in localStorage){if(key.startsWith('pm.chat.')){
      const label=key.replace('pm.chat.','');const div=document.createElement('div');div.className='card';div.style.margin='6px 0';div.textContent=label;div.onclick=()=>{loadChat(label)};chatsList.appendChild(div);
    }} if(!chatsList.children.length) chatsList.textContent='(нет подключений)';
  }
  function loadChat(label){
    chatEl.innerHTML='';const arr=JSON.parse(localStorage.getItem('pm.chat.'+label)||'[]');for(const it of arr){appendMsg(it.m, it.w)} connId=label;}

  // --- create peer connection and data channel
  function createPeerConnection(isCaller){
    pc=new RTCPeerConnection({iceServers:[{urls:['stun:stun.l.google.com:19302']}]});
    pc.onicecandidate=e=>{
      // we will include gathered candidates in SDP (auto)
      // when gathering finishes, localDescription will contain them (browsers gather progressively). user will copy SDP manually.
      // nothing to do here.
    };
    pc.ondatachannel=e=>{
      dc=e.channel;setupDataChannel(dc);
    };
    // optional: collect connection state
    pc.onconnectionstatechange=()=>{console.log('pc state',pc.connectionState)};
  }

  function setupDataChannel(channel){
    dc=channel;dc.onopen=()=>{appendMsg('DataChannel открыт — можно писать','them');updateConnectionList();};
    dc.onmessage=async (ev)=>{
      try{
        const payload=JSON.parse(ev.data);
        if(payload.type==='enc'){
          if(!cryptoKey) appendMsg('[Зашифрованное сообщение] (пароль не установлен)');
          else{
            const plain=await decryptMessage(cryptoKey,payload.iv,payload.ct);
            appendMsg(plain,'them');saveChat(connId||'peer',plain,'them');
          }
        } else if(payload.type==='plain'){
          appendMsg(payload.text,'them');saveChat(connId||'peer',payload.text,'them');
        } else if(payload.type==='meta'){
          connId=payload.nick||'peer';updateConnectionList();
        }
      }catch(err){console.error(err);appendMsg('[Ошибка при расшифровке/получении]');}
    };
  }

  // --- buttons
  makeOfferBtn.onclick=async ()=>{
    createPeerConnection(true);
    const channel=pc.createDataChannel('chat');
    setupDataChannel(channel);
    const offer=await pc.createOffer();
    await pc.setLocalDescription(offer);
    // wait for ICE gathering? we won't wait: give current localDescription. User may copy/paste later after candidates have been added.
    setTimeout(()=>{localSDP.value=JSON.stringify(pc.localDescription);},500);
  };

  makeAnswerBtn.onclick=async ()=>{
    // if user pasted an offer into remoteSDP, create answer
    if(!remoteSDP.value){alert('Вставьте офер в поле удалённой SDP');return}
    createPeerConnection(false);
    const offer=JSON.parse(remoteSDP.value);
    await pc.setRemoteDescription(offer);
    const answer=await pc.createAnswer();
    await pc.setLocalDescription(answer);
    setTimeout(()=>{localSDP.value=JSON.stringify(pc.localDescription);},500);
  };

  acceptRemote.onclick=async ()=>{
    if(!remoteSDP.value){alert('Вставьте удалённую SDP');return}
    const desc=JSON.parse(remoteSDP.value);
    if(!pc){
      // if desc is offer -> we should create answer (makeAnswerBtn does same but here we accept directly)
      createPeerConnection(desc.type==='offer');
    }
    await pc.setRemoteDescription(desc);
    // if we are the caller and got answer, nothing more to do
    // if we are callee and created answer earlier, user already has localSDP to send
    // save metadata: send our nick
    sendMeta();
  };

  resetBtn.onclick=()=>{if(dc)dc.close();if(pc)pc.close();pc=null;dc=null;localSDP.value='';remoteSDP.value='';connId=null;renderChats();chatEl.innerHTML='';}

  sendBtn.onclick=async ()=>{
    const text=msgInput.value.trim(); if(!text||!dc||dc.readyState!=='open')return;const nick=nickEl.value||'me';
    if(passEl.value){ // encrypt with derived key
      if(!cryptoKey){ // derive key
        salt=crypto.getRandomValues(new Uint8Array(16));
        cryptoKey=await deriveKeyFromPassword(passEl.value, salt);
      }
      // encrypt
      const enc=await encryptMessage(cryptoKey,text);
      // include salt once as meta if not sent
      const payload={type:'enc',iv:enc.iv,ct:enc.ct,salt:bufToBase64(salt)};
      dc.send(JSON.stringify(payload));
      appendMsg(text,'me');saveChat(connId||'peer',text,'me');msgInput.value='';
    } else {
      const payload={type:'plain',text:text};dc.send(JSON.stringify(payload));appendMsg(text,'me');saveChat(connId||'peer',text,'me');msgInput.value='';
    }
  };

  async function sendMeta(){if(!dc||dc.readyState!='open')return;const payload={type:'meta',nick:nickEl.value||'peer'};dc.send(JSON.stringify(payload));}

  function updateConnectionList(){
    // create a simple label in localStorage so user sees known peer
    const label=connId||'peer';localStorage.setItem('pm.peer.'+label, Date.now());renderChats();
  }

  // on load, render saved chats
  renderChats();

  // Auto-handle incoming salt: if we receive an encrypted message with salt, derive key if password matches
  // (note: current receive handler expects salt to be included in each message if sender set salt)

  // small UX: if user pastes remote SDP that looks like answer and we are caller, set remote and finish
  // Not implemented more deeply to keep single-file simple.

  </script>
</body>
</html>
